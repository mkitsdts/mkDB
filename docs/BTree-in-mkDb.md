---
title: BTree in mkDb
date: 2024-10-28 15:11:08
tags: mkDB
author: mkitsdts
---
数据引擎采用的数据结构是B+树，也是B树的改进版本。为了在实现的时候思路更加清晰，所以先写下一篇blog记录我对B+树的认知以及认知的变化情况。

# 为什么是B+树
要解决这个疑问，要先明白数据引擎需要什么样的结构，在此之前，还要先了解数据引擎需要的是什么，然后根据需求对应的设计或者寻找适合的数据结构。
我们知道，对于一个程序而言，对数据库只有一点要求，就是在不出错的情况下尽可能快。因此，快是数据引擎需要的。
了解了数据引擎的需要后，就该分析数据引擎的需要了。速度是根本，提升速度的办法有减少磁盘读写次数，减少数据库上锁时间等，毕竟一个人的快不是快，一群人快才是真的快。

## 减少磁盘读写次数：
数据库建立在外存上，要想速度快就得减少读取次数，最好能一次性把数据全部读入。这样红黑树、哈希表、AVL树，链表还有链表改进的跳表这些都不是一个好的选择，因为这些结构的数据分散，不能快速大量读取。
## 减少数据库上锁时间：
要减少数据库上锁时间，那数据在创建和删除过程应该尽可能地少操作，不能像数组一样，插入和删除都需要O(n)的时间复杂度，得像链表这样插入和删除都只需要O(1)的时间复杂度。

综上，可以确定数组，链表，红黑树，哈希表都不适合作为数据引擎存储的数据结构，因为他们的优缺点都很明显。聪明的人可能已经想到，为什么要做选择，难道不能用树存储数组吗？可以用树的结构存储数组，这样不是既减少了磁盘读写次数，也减少了数据操作时的步骤也就是减少数据库上锁的时间。B+树就是在这样条件下诞生的。

至此，确定采用B+树。

# 如何使用B+树
确定了B+树后，就到了设计树节点的时候了。树的节点究竟该存储哪些内容呢？

## 根节点
B+树的根节点存储很多个键，这些键都已经按从小到大的顺序排好序的，搜索的时候只需要找到键对应的范围然后进入对应的子节点即可。
在具体实现上根节点会常驻内存。
## 子节点
根节点下面有很多个子节点，子节点的数量等于根节点存储的键的数量，并且子节点最大值或最小值就是对应根节点所存储的键。
举个例子，一个三阶B+树，根节点就有3个键，假设分别为1，5，9。相应地，子节点也有3个，第一个子节点的键取值范围是[1,5)，最小值等于根节点的1，以此类推，第二个子节点的键取值范围在[5,9)，最小值是根节点的5，第三个子节点取值则是[9,13)，如果出现了大于13的键那么B+树根节点会扩充。
在具体实现时子节点位于外存。
## 叶子节点
子节点会指向叶子节点，叶子节点就是对应的数据了。只要找到子节点对应的键，我们就能够找到该键所对应的数据的地址。

# 如何实现B+树
了解B+树原理后就可以动手实现B+树了，实现B+树需要几个模板作为参数，具体代码麻烦移步github主页。